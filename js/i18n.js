const translations = {
    zh: {
        app_title: "ðŸŽ™ï¸ éº¦å…‹ç–¯",
        join_room_title: "åŠ å…¥æˆ¿é—´",
        join_room_subtitle: "è¾“å…¥æˆ¿é—´åå¼€å§‹å®žæ—¶éŸ³é¢‘é€šè¯",
        room_id: "æˆ¿é—´ ID",
        room_placeholder: "è¾“å…¥æˆ¿é—´å...",
        join_btn: "ðŸš€ åŠ å…¥æˆ¿é—´",
        status_ready: "å‡†å¤‡å°±ç»ª",
        nearby_rooms: "ðŸ  é™„è¿‘æˆ¿é—´",
        select_mode_title: "é€‰æ‹©æ¨¡å¼",
        select_mode_subtitle: "é€‰æ‹©ä½ åœ¨é€šè¯ä¸­çš„è§’è‰²",
        broadcast_mode: "å¹¿æ’­æ¨¡å¼",
        broadcast_desc: "åˆ†äº«ä½ çš„éº¦å…‹é£Ž",
        listen_mode: "æ”¶å¬æ¨¡å¼",
        listen_desc: "æŽ¥æ”¶éŸ³é¢‘æ’­æ”¾",
        sender_title: "ðŸŽ™ï¸ å¹¿æ’­æ¨¡å¼",
        sender_subtitle: "æ­£åœ¨åˆ†äº«ä½ çš„éº¦å…‹é£Ž",
        audio_mode: "ðŸŽ§ éŸ³é¢‘æ¨¡å¼",
        speech_mode: "ðŸ—£ï¸ äººå£°æ¨¡å¼ (ä¼šè®®/èŠå¤©)",
        music_mode: "ðŸŽµ éŸ³ä¹æ¨¡å¼ (é«˜ä¿çœŸ)",
        audio_opt: "ðŸ›¡ï¸ éŸ³é¢‘ä¼˜åŒ–",
        echo_cancel: "å›žå£°æ¶ˆé™¤",
        noise_supp: "å™ªå£°æŠ‘åˆ¶",
        auto_gain: "è‡ªåŠ¨å¢žç›Š",
        audio_source: "ðŸ”Š éŸ³é¢‘æº",
        add_system_audio: "ðŸ–¥ï¸ æ·»åŠ ç³»ç»Ÿå£°éŸ³ (å…±äº«å±å¹•/æ ‡ç­¾é¡µ)",
        start_sending: "ðŸ“¡ å¼€å§‹å‘é€",
        pause_mute: "â¸ï¸ æš‚åœ (Mute)",
        resume_unmute: "â–¶ï¸ æ¢å¤ (Resume)",
        start_recording: "ðŸ”´ å¼€å§‹å½•éŸ³",
        stop_recording: "â¹ï¸ åœæ­¢å½•éŸ³",
        end_call: "âŒ ç»“æŸé€šè¯",
        receiver_title: "ðŸŽ§ æ”¶å¬æ¨¡å¼",
        receiver_subtitle: "æ­£åœ¨æŽ¥æ”¶éŸ³é¢‘",
        output_device: "ðŸ”Š è¾“å‡ºè®¾å¤‡",
        default_device: "é»˜è®¤è®¾å¤‡",
        speaker_group: "ðŸ”ˆ æ‰¬å£°å™¨ (Speakers)",
        virtual_group: "ðŸŽ¤ è™šæ‹Ÿéº¦å…‹é£Ž (Virtual Cables)",
        volume_control: "ðŸ”Š éŸ³é‡è°ƒèŠ‚",
        disconnect: "âŒ æ–­å¼€è¿žæŽ¥",
        switch_lang: "ðŸŒ ZH",
        alert_no_output_support: "æ— æ³•åˆ‡æ¢è¾“å‡ºè®¾å¤‡ (å¯èƒ½ä¸æ”¯æŒæˆ–æƒé™ä¸è¶³)",
        visual_virt: "ðŸ’¡ [è™šä¼¼] ",
        recording_started: "ðŸ”´ å½•éŸ³ä¸­",
        status_connecting: "æ­£åœ¨è¿žæŽ¥...",
        status_connected: "å·²è¿žæŽ¥",
        status_disconnected: "å·²æ–­å¼€",
        status_error: "è¿žæŽ¥å¤±è´¥"
    },
    en: {
        app_title: "ðŸŽ™ï¸ MicF",
        join_room_title: "Join Room",
        join_room_subtitle: "Enter room name to start real-time audio",
        room_id: "Room ID",
        room_placeholder: "Enter room name...",
        join_btn: "ðŸš€ Join Room",
        status_ready: "Ready",
        nearby_rooms: "ðŸ  Nearby Rooms",
        select_mode_title: "Select Mode",
        select_mode_subtitle: "Choose your role in the call",
        broadcast_mode: "Broadcast Mode",
        broadcast_desc: "Share your microphone",
        listen_mode: "Listen Mode",
        listen_desc: "Receive audio playback",
        sender_title: "ðŸŽ™ï¸ Broadcast Mode",
        sender_subtitle: "Sharing your microphone",
        audio_mode: "ðŸŽ§ Audio Mode",
        speech_mode: "ðŸ—£ï¸ Speech Mode (Chat/Meeting)",
        music_mode: "ðŸŽµ Music Mode (High Fidelity)",
        audio_opt: "ðŸ›¡ï¸ Audio Optimization",
        echo_cancel: "Echo Cancellation",
        noise_supp: "Noise Suppression",
        auto_gain: "Auto Gain Control",
        audio_source: "ðŸ”Š Audio Source",
        add_system_audio: "ðŸ–¥ï¸ Add System Audio (Screen/Tab)",
        start_sending: "ðŸ“¡ Start Sending",
        pause_mute: "â¸ï¸ Mute",
        resume_unmute: "â–¶ï¸ Unmute",
        start_recording: "ðŸ”´ Start Recording",
        stop_recording: "â¹ï¸ Stop Recording",
        end_call: "âŒ End Call",
        receiver_title: "ðŸŽ§ Listen Mode",
        receiver_subtitle: "Receiving audio",
        output_device: "ðŸ”Š Output Device",
        default_device: "Default Device",
        speaker_group: "ðŸ”ˆ Speakers",
        virtual_group: "ðŸŽ¤ Virtual Microphones",
        volume_control: "ðŸ”Š Volume",
        disconnect: "âŒ Disconnect",
        switch_lang: "ðŸŒ EN",
        alert_no_output_support: "Cannot switch output device (Unsupported or no permission)",
        visual_virt: "ðŸ’¡ [Virtual] ",
        recording_started: "ðŸ”´ Recording",
        status_connecting: "Connecting...",
        status_connected: "Connected",
        status_disconnected: "Disconnected",
        status_error: "Connection Failed"
    }
};

let currentLang = localStorage.getItem('lang') || (navigator.language.startsWith('zh') ? 'zh' : 'en');

export function t(key) {
    return translations[currentLang][key] || key;
}

export function getCurrentLang() {
    return currentLang;
}

export function setLang(lang) {
    if (translations[lang]) {
        currentLang = lang;
        localStorage.setItem('lang', lang);
        applyTranslations();
        return true;
    }
    return false;
}

export function toggleLang() {
    const newLang = currentLang === 'zh' ? 'en' : 'zh';
    setLang(newLang);
    return newLang;
}

export function applyTranslations() {
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        const translation = t(key);
        if (translation) {
            // Special handling for elements with children (like buttons with spans)
            const iconSpan = el.querySelector('span');
            if (iconSpan) {
                // Preserving the icon span and updating the text node
                // Find the first text node child
                let textNodeFound = false;
                el.childNodes.forEach(node => {
                    if (node.nodeType === 3 && node.textContent.trim().length > 0 && !textNodeFound) {
                        // Translation key usually includes emoji, if index.html already has span icon, 
                        // we might want just the text part or replace entirely.
                        // Actually, the keys like join_btn include the emoji: "ðŸš€ Join Room"
                        // If index.html has <span>ðŸš€</span>, we should probably just update the text part.
                        // But let's simplify: if it has data-i18n, replace WHOLE content but keep span if we can.
                    }
                });
                // Simple approach: reset innerHTML but keep span if it was there
                const emoji = iconSpan.textContent;
                el.innerHTML = `<span>${emoji}</span> ${translation.replace(/^[^\s]+\s/, '')}`;
            } else {
                el.textContent = translation;
            }
        }
    });

    // Placeholders
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        el.placeholder = t(key);
    });

    // Update switcher dropdown active state
    document.querySelectorAll('.lang-option').forEach(el => {
        el.classList.toggle('active', el.getAttribute('data-lang') === currentLang);
    });
}

// Initialize on load
document.addEventListener('DOMContentLoaded', applyTranslations);
